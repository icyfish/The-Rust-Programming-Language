<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.36">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <title>Rust 程序设计语言</title><meta name="description" content="Translation of The Rust Programming Language">
    <link rel="modulepreload" href="/the-rust-programming-language/assets/app.b3a2ff78.js"><link rel="modulepreload" href="/the-rust-programming-language/assets/02-example-structs.html.1a3101f0.js"><link rel="modulepreload" href="/the-rust-programming-language/assets/02-example-structs.html.aa5aa364.js"><link rel="modulepreload" href="/the-rust-programming-language/assets/plugin-vue_export-helper.21dcd24c.js">
    <link rel="stylesheet" href="/the-rust-programming-language/assets/style.28c61a90.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header ref_key="navbar" class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/the-rust-programming-language/" class=""><!----><span class="site-name">Rust 程序设计语言</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a class="external-link" href="https://github.com/icyfish/the-rust-programming-language" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><form class="search-box" role="search"><input type="search" placeholder="搜索" autocomplete="off" spellcheck="false" value><!----></form></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a class="external-link" href="https://github.com/icyfish/the-rust-programming-language" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><a href="/the-rust-programming-language/ch01/00-getting-started.md" class="sidebar-item sidebar-heading" aria-label="1. 入门"><!--[--><!--]--> 1. 入门 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/the-rust-programming-language/ch01/01-installation.md" class="sidebar-item" aria-label="1.1 安装"><!--[--><!--]--> 1.1 安装 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/the-rust-programming-language/ch04/00-understanding-ownership.md" class="sidebar-item sidebar-heading" aria-label="4. 理解所有权"><!--[--><!--]--> 4. 理解所有权 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/the-rust-programming-language/ch04/01-what-is-ownership.md" class="sidebar-item" aria-label="4.1 什么是所有权"><!--[--><!--]--> 4.1 什么是所有权 <!--[--><!--]--></a><!----></li><li><a href="/the-rust-programming-language/ch04/02-references-and-borrowing.md" class="sidebar-item" aria-label="4.2 引用与借用"><!--[--><!--]--> 4.2 引用与借用 <!--[--><!--]--></a><!----></li><li><a href="/the-rust-programming-language/ch04/03-slices.md" class="sidebar-item" aria-label="4.3 Slice 类型"><!--[--><!--]--> 4.3 Slice 类型 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/the-rust-programming-language/ch05/00-structs.md" class="sidebar-item sidebar-heading active" aria-label="5. 使用结构体来组织相关联的数据"><!--[--><!--]--> 5. 使用结构体来组织相关联的数据 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/the-rust-programming-language/ch05/01-defining-structs.md" class="sidebar-item" aria-label="5.1 定义并实例化结构体"><!--[--><!--]--> 5.1 定义并实例化结构体 <!--[--><!--]--></a><!----></li><li><a href="/the-rust-programming-language/ch05/02-example-structs.md" class="sidebar-item active" aria-label="5.2 使用结构体的示例程序"><!--[--><!--]--> 5.2 使用结构体的示例程序 <!--[--><!--]--></a><!----></li><li><a href="/the-rust-programming-language/ch05/03-method-syntax.md" class="sidebar-item" aria-label="5.3 方法语法"><!--[--><!--]--> 5.3 方法语法 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/the-rust-programming-language/ch06/00-enums" class="sidebar-item sidebar-heading" aria-label="6. 枚举和模式匹配"><!--[--><!--]--> 6. 枚举和模式匹配 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/the-rust-programming-language/ch06/01-defining-an-enum" class="sidebar-item" aria-label="6.1 定义枚举"><!--[--><!--]--> 6.1 定义枚举 <!--[--><!--]--></a><!----></li><li><a href="/the-rust-programming-language/ch06/02-match" class="sidebar-item" aria-label="6.2 match 控制流结构体"><!--[--><!--]--> 6.2 match 控制流结构体 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><nav class="table-of-contents"><ul><li><a aria-current="page" href="/the-rust-programming-language/ch05/02-example-structs.html#_5-2-使用结构体的示例程序" class="router-link-active router-link-exact-active">5.2 使用结构体的示例程序</a><ul><li><a aria-current="page" href="/the-rust-programming-language/ch05/02-example-structs.html#使用元组进行重构" class="router-link-active router-link-exact-active">使用元组进行重构</a></li><li><a aria-current="page" href="/the-rust-programming-language/ch05/02-example-structs.html#用结构体进行重构-让代码表达它的含义" class="router-link-active router-link-exact-active">用结构体进行重构: 让代码表达它的含义</a></li><li><a aria-current="page" href="/the-rust-programming-language/ch05/02-example-structs.html#使用派生的-trait-添加一些有用的功能" class="router-link-active router-link-exact-active">使用派生的 trait 添加一些有用的功能</a></li></ul></li></ul></nav><h2 id="_5-2-使用结构体的示例程序" tabindex="-1"><a class="header-anchor" href="#_5-2-使用结构体的示例程序" aria-hidden="true">#</a> 5.2 使用结构体的示例程序</h2><p>为了更好地理解何时使用结构体, 我们来编写一个程序, 这个程序的功能是计算一个长方形的面积. 初版本先使用单独的变量, 然后开始重构程序, 直到使用结构体来替代单独的变量为止.</p><p>首先用 Cargo 创建一个新的二进制项目, 将其命名为 <em>rectangles</em>, 该程序接收以像素为单位的宽度和高度值, 程序根据这两个值计算出长方形的面积. 代码示例5-8就实现了这一功能:</p><div class="language-rust ext-rs line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> width1 <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> height1 <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">;</span>

    <span class="token macro property">println!</span><span class="token punctuation">(</span>
        <span class="token string">&quot;The area of the rectangle is {} square pixels.&quot;</span><span class="token punctuation">,</span>
        <span class="token function">area</span><span class="token punctuation">(</span>width1<span class="token punctuation">,</span> height1<span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">area</span><span class="token punctuation">(</span>width<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span> height<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">u32</span> <span class="token punctuation">{</span>
    width <span class="token operator">*</span> height
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>现在执行 <code>cargo run</code> 来运行程序:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ cargo run
   Compiling rectangles v0.1.0 <span class="token punctuation">(</span>file:///projects/rectangles<span class="token punctuation">)</span>
    Finished dev <span class="token punctuation">[</span>unoptimized + debuginfo<span class="token punctuation">]</span> target<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token number">0</span>.42s
     Running <span class="token variable"><span class="token variable">`</span>target/debug/rectangles<span class="token variable">`</span></span>
The area of the rectangle is <span class="token number">1500</span> square pixels.
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>代码通过调用 <code>area</code> 函数确实获取了我们想要的结果, 但我们可以对其进行进一步优化使得代码更加清晰可读:</p><p>代码中的问题很明显出现在 <code>area</code> 的函数签名中:</p><div class="language-rust ext-rs line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> width1 <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> height1 <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">;</span>

    <span class="token macro property">println!</span><span class="token punctuation">(</span>
        <span class="token string">&quot;The area of the rectangle is {} square pixels.&quot;</span><span class="token punctuation">,</span>
        <span class="token function">area</span><span class="token punctuation">(</span>width1<span class="token punctuation">,</span> height1<span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">area</span><span class="token punctuation">(</span>width<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span> height<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">u32</span> <span class="token punctuation">{</span>
    width <span class="token operator">*</span> height
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p><code>area</code> 函数支持计算一个长方形的面积, 但是该函数接收两个参数, 但我们的程序代码中并没有清晰地体现出这两个参数的关联. 如果宽度和高度是在一个集合中的话, 代码的可读性就会更高, 也更容易管理. 优化的其中一种方式是使用元组, 我们在第三章的<a href="https://doc.rust-lang.org/book/ch03-02-data-types.html#the-tuple-type" target="_blank" rel="noopener noreferrer">元组类型<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>章节已经对元组做过介绍.</p><h3 id="使用元组进行重构" tabindex="-1"><a class="header-anchor" href="#使用元组进行重构" aria-hidden="true">#</a> 使用元组进行重构</h3><p>代码示例5-9展示了用元组实现的另一个版本:</p><div class="language-rust ext-rs line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> rect1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token macro property">println!</span><span class="token punctuation">(</span>
        <span class="token string">&quot;The area of the rectangle is {} square pixels.&quot;</span><span class="token punctuation">,</span>
        <span class="token function">area</span><span class="token punctuation">(</span>rect1<span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">area</span><span class="token punctuation">(</span>dimensions<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token keyword">u32</span><span class="token punctuation">,</span> <span class="token keyword">u32</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">u32</span> <span class="token punctuation">{</span>
    dimensions<span class="token number">.0</span> <span class="token operator">*</span> dimensions<span class="token number">.1</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>在某种程度上, 这个版本的程序更好一些. 使用元组使得代码更加结构化, 我们的函数也只需接受一个参数即可. 但从另一方面看, 这个版本代码其实更不清晰: 由于是元组中的元素, 无法对其进行命名, 因此我们必须使用索引来获取参数中的宽高值, 这样一来, 计算的代码其实含义更不清晰了.</p><p>尽管弄混宽高不会对面积的计算产生影响, 但如果我们希望在屏幕上画出这个长方形, 情况就不一样了. 此时我们就必须记住索引 <code>0</code> 是宽度, 索引 <code>1</code> 是高度. 如果别人阅读我们的代码, 就会觉得很疑惑, 因为我们没有在代码中清晰地呈现各个数据所表达的含义, 这会很容易产生错误.</p><h3 id="用结构体进行重构-让代码表达它的含义" tabindex="-1"><a class="header-anchor" href="#用结构体进行重构-让代码表达它的含义" aria-hidden="true">#</a> 用结构体进行重构: 让代码表达它的含义</h3><p>我们利用结构体来给代码赋予含义的方式是通过给数据添加标签. 实际上就是将元组转化为结构体, 给结构体本身和其中的元素添加命名, 如代码示例5-10所示:</p><div class="language-rust ext-rs line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">struct</span> <span class="token type-definition class-name">Rectangle</span> <span class="token punctuation">{</span>
    width<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span>
    height<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> rect1 <span class="token operator">=</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>
        width<span class="token punctuation">:</span> <span class="token number">30</span><span class="token punctuation">,</span>
        height<span class="token punctuation">:</span> <span class="token number">50</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token macro property">println!</span><span class="token punctuation">(</span>
        <span class="token string">&quot;The area of the rectangle is {} square pixels.&quot;</span><span class="token punctuation">,</span>
        <span class="token function">area</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rect1<span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">area</span><span class="token punctuation">(</span>rectangle<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Rectangle</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">u32</span> <span class="token punctuation">{</span>
    rectangle<span class="token punctuation">.</span>width <span class="token operator">*</span> rectangle<span class="token punctuation">.</span>height
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>这里我们定义了一个结构体并将其命名为 <code>Rectangle</code>. 在大括号中定义字段 <code>width</code> 和 <code>height</code>, 两者的类型都是 <code>u32</code>. 然后在 <code>main</code> 函数中, 我们创建一个 <code>Rectangle</code> 的实例, 其中宽度值为 30, 高度值为 50.</p><p>我们的 <code>area</code> 函数现在只接受一个参数 <code>rectangle</code>, 其类型为结构体 <code>Rectangle</code> 实例的不可变借用. 记得我们在第四章中说到, 我们希望借用结构体而不是获取它的所有权. 这样的话, <code>main</code> 函数就能够保持对 <code>rect1</code> 的所有权并继续使用它, 这也是我们要在函数签名和函数调用的代码中使用 <code>&amp;</code> 的原因.</p><p><code>area</code> 函数会访问 <code>Rectangle</code> 实例的 <code>width</code> 和 <code>height</code> 字段. <code>area</code> 函数签名现在已经很清楚地呈现了我们想要表达的意思: 利用字段 <code>width</code> 和 <code>height</code> 的值, 计算 <code>Rectangle</code> 的面积. 同时函数签名也表达出了 <code>width</code> 和 <code>height</code> 之前是有关联的. 这比使用元组读取索引 <code>0</code> 和 <code>1</code> 的值含义清楚多了. 结构体的优势就在于含义清晰.</p><h3 id="使用派生的-trait-添加一些有用的功能" tabindex="-1"><a class="header-anchor" href="#使用派生的-trait-添加一些有用的功能" aria-hidden="true">#</a> 使用派生的 trait 添加一些有用的功能</h3><p>当我们在调试程序时, 如果能够打印出 <code>Rectangle</code> 的实例并且查看实例中每一个字段的值, 对调试会有很大的帮助. 代码示例5-11中尝试使用 <a href="https://doc.rust-lang.org/std/macro.println.html" target="_blank" rel="noopener noreferrer"><code>println</code> 宏方法<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>来达到这个目的, 但是并不像我们预期的那样输出结果:</p><div class="language-rust ext-rs line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">struct</span> <span class="token type-definition class-name">Rectangle</span> <span class="token punctuation">{</span>
    width<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span>
    height<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> rect1 <span class="token operator">=</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>
        width<span class="token punctuation">:</span> <span class="token number">30</span><span class="token punctuation">,</span>
        height<span class="token punctuation">:</span> <span class="token number">50</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;rect1 is {}&quot;</span><span class="token punctuation">,</span> rect1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>当我们编译以上代码的时候, 会看到以下错误信息:</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>error[E0277]: `Rectangle` doesn&#39;t implement `std::fmt::Display`
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p><code>println</code> 宏能够处理多种类型的格式, 默认情况下, 使用大括号 <code>{}</code> 表示使用 <code>Display</code> 格式: 即直接输出给终端用户查看的格式. 目前我们知道的原始类型都默认实现了 <code>Display</code> 格式, 因为如果你想展示 <code>1</code> 或者其他原始类型的数据给用户, 只有一种展示方式. 不过对于结构体类型来说, <code>println</code> 所输出的默认格式就无法清晰地表达含义了, 因为结构体类型结构复杂, 所以在展示上有更多的可能性: 是否需要逗号? 是否需要打印出大括号? 是否要展示出所有字段? 由于不确定性太大, Rust 并不会尝试猜测我们的意图, 结构体类型本身也没有提供 <code>Display</code> 的实现供 <code>println!</code> 和 <code>{}</code> 占位符使用.</p><p>如果持续遇到错误, 我们可以从错误信息中找到一些可用的提示:</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>   = help: the trait `std::fmt::Display` is not implemented for `Rectangle`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>现在开始试试看. <code>println!</code> 宏调用现在看起来像是这样的格式: <code>println!(&quot;rect1 is {:?}&quot;, rect1);</code>. 在 <code>{}</code> 内部加上 <code>:?</code> 指示符的含义是告诉 <code>println!</code> 我们想要使用 <code>Debug</code> 类的输出格式. <code>Debug</code> trait 使得输出结构体时能够披露更多对开发者有用的信息, 帮助开发者更有效地调试代码.</p><p>现在做出些许改动. 但是依然有报错:</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>error[E0277]: `Rectangle` doesn&#39;t implement `Debug`
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>不过不用担心, 编译器输出了一些有用的信息:</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>   = help: the trait `Debug` is not implemented for `Rectangle`
   = note: add `#[derive(Debug)]` to `Rectangle` or manually `impl Debug for Rectangle`
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Rust 确实内置了输出调试信息的功能, 但是我们必须为结构体手动开启这个功能. 具体的操作方式是: 在结构体定义之前加上外部属性 <code>#[derive(Debug)]</code>, 具体如代码示例5-12所示:</p><div class="language-rust ext-rs line-numbers-mode"><pre class="language-rust"><code><span class="token attribute attr-name">#[derive(Debug)]</span>
<span class="token keyword">struct</span> <span class="token type-definition class-name">Rectangle</span> <span class="token punctuation">{</span>
    width<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span>
    height<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> rect1 <span class="token operator">=</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>
        width<span class="token punctuation">:</span> <span class="token number">30</span><span class="token punctuation">,</span>
        height<span class="token punctuation">:</span> <span class="token number">50</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;rect1 is {:?}&quot;</span><span class="token punctuation">,</span> rect1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>现在我们开始执行程序, 执行过程不会有任何错误, 然后会看到以下输出结果:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ cargo run
   Compiling rectangles v0.1.0 <span class="token punctuation">(</span>file:///projects/rectangles<span class="token punctuation">)</span>
    Finished dev <span class="token punctuation">[</span>unoptimized + debuginfo<span class="token punctuation">]</span> target<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token number">0</span>.48s
     Running <span class="token variable"><span class="token variable">`</span>target/debug/rectangles<span class="token variable">`</span></span>
rect1 is Rectangle <span class="token punctuation">{</span> width: <span class="token number">30</span>, height: <span class="token number">50</span> <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>或许以上的输出并非最完美的结果, 但是确实展示了该结构体实例的所有字段值, 对我们的调试很有帮助. 当我们的结构体更复杂的情况下, 这样的输出就使得代码更加清晰; 在这些情况下, 我们可以考虑在 <code>println!</code> 中使用 <code>{:#}?</code> 来替代 <code>{:?}</code>. 在本例中, 使用 <code>{:#}?</code> 将会输出:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ cargo run
   Compiling rectangles v0.1.0 <span class="token punctuation">(</span>file:///projects/rectangles<span class="token punctuation">)</span>
    Finished dev <span class="token punctuation">[</span>unoptimized + debuginfo<span class="token punctuation">]</span> target<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token number">0</span>.48s
     Running <span class="token variable"><span class="token variable">`</span>target/debug/rectangles<span class="token variable">`</span></span>
rect1 is Rectangle <span class="token punctuation">{</span>
    width: <span class="token number">30</span>,
    height: <span class="token number">50</span>,
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>另一种使用 <code>Debug</code> 格式输出值的方式是利用 <a href="https://doc.rust-lang.org/std/macro.dbg.html" target="_blank" rel="noopener noreferrer"><code>dbg!</code> 宏<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>, 该方法会接收某个表达式的所有权, 打印出代码中调用 <code>dbg!</code> 宏的代码所在文件及行号, 以及这个表达式的结果值, 并返回该值的所有权.</p><div class="custom-container tip"><p class="custom-container-title">注意</p><p>调用 <code>dbg!</code> 宏的输出会存在于标准错误控制台流(<code>stderr</code>), 而 <code>println!</code> 宏的输出则存在于标准输出控制台流(<code>stdout</code>). 在<a href="https://doc.rust-lang.org/book/ch12-06-writing-to-stderr-instead-of-stdout.html" target="_blank" rel="noopener noreferrer">第 12 章的&quot;写入错误信息到标准错误控制台中而不是标准输出控制台&quot;章节<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>中, 我们会讨论更多关于 <code>stderr</code> 和 <code>stdout</code> 的内容.</p></div><p>下面的示例中, 我们会关注赋给 <code>width</code> 字段的值, 同时还有整个结构体实例 <code>rect1</code> 中的值:</p><div class="language-rust ext-rs line-numbers-mode"><pre class="language-rust"><code><span class="token attribute attr-name">#[derive(Debug)]</span>
<span class="token keyword">struct</span> <span class="token type-definition class-name">Rectangle</span> <span class="token punctuation">{</span>
    width<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span>
    height<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> scale <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> rect1 <span class="token operator">=</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>
        width<span class="token punctuation">:</span> <span class="token macro property">dbg!</span><span class="token punctuation">(</span><span class="token number">30</span> <span class="token operator">*</span> scale<span class="token punctuation">)</span><span class="token punctuation">,</span>
        height<span class="token punctuation">:</span> <span class="token number">50</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token macro property">dbg!</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rect1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>我们用 <code>dbg!</code> 来输出表达式 <code>30 * scale</code> 的结果, 因为 <code>dbg!</code> 返回了这个表达式值的所有权, 此时 <code>width</code> 字段的值与 <code>30 * scale</code> 的结果无异. 我们并不希望 <code>dbg!</code> 拿走 <code>rect1</code> 的控制权, 因此在后续的函数调用中, 我们使用了 <code>rect1</code> 的引用. 以上的代码的输出大概会是下面这样:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ cargo run
   Compiling rectangles v0.1.0 <span class="token punctuation">(</span>file:///projects/rectangles<span class="token punctuation">)</span>
    Finished dev <span class="token punctuation">[</span>unoptimized + debuginfo<span class="token punctuation">]</span> target<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token number">0</span>.61s
     Running <span class="token variable"><span class="token variable">`</span>target/debug/rectangles<span class="token variable">`</span></span>
<span class="token punctuation">[</span>src/main.rs:10<span class="token punctuation">]</span> <span class="token number">30</span> * scale <span class="token operator">=</span> <span class="token number">60</span>
<span class="token punctuation">[</span>src/main.rs:14<span class="token punctuation">]</span> <span class="token operator">&amp;</span>rect1 <span class="token operator">=</span> Rectangle <span class="token punctuation">{</span>
    width: <span class="token number">60</span>,
    height: <span class="token number">50</span>,
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>输出结果的第一部分来自文件 <em>src/main.rs</em> 的第 10 行, 在这里我们调试输出(<code>!dbg</code>)了 <code>30 * scale</code> 的值, 该表达式的最终结果是 60(为整数实现的 <code>Debug</code> 模式只会单纯打印它们的值). 在同一个文件的第 14 行中, 调用 <code>dbg!</code> 输出了 <code>&amp;rect1</code> 的值, 也就是结构体 <code>Rectangle</code>. 此时的输出格式采用了 <code>Rectangle</code> 类型的 <code>Debug</code> 模式, 可读性更高. <code>dbg!</code> 宏对我们调试代码有很大的帮助, 特别是当我们想要搞清楚我们的代码具体做了些什么的时候.</p><p>除了 <code>Debug</code> trait, Rust 还提供了很多其他的 trait, 不过这些 trait 需要配合 <code>derive</code> 属性进行使用, 它们为我们的自定义类型额外实现了许多实用的行为. 想要了解这些 trait 以及它们的行为, 可以查看<a href="https://doc.rust-lang.org/book/appendix-03-derivable-traits.html" target="_blank" rel="noopener noreferrer">附录 C<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>. 在第 10 章中, 我们会学习如何实现这些 trait 以及自定义行为, 同时还会学习如何实现我们自己的 trait. 除了 <code>derive</code> 之外, 还有许多其他属性, 可以查看 <a href="https://doc.rust-lang.org/reference/attributes.html" target="_blank" rel="noopener noreferrer">Rust 参考目录中的&quot;属性&quot;章节部分<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>.</p><p><code>area</code> 函数的行为很具体: 只计算了长方形的面积. 如果将这个函数的行为和 <code>Rectangle</code> 结构体关联起来, 它会更加实用, 因为对于其他类型来说, 这个函数其实没有任何用处. 那么接下来, 我们开始看看应该如何重构我们的代码, 将 <code>area</code> 函数转换成 <code>area</code> 方法, 使其与 <code>Rectangle</code> 函数体类型进行关联.</p><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: icyyfish@gmail.com">Fish</span><!----><!--]--><!--]--></span></div></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/the-rust-programming-language/assets/app.b3a2ff78.js" defer></script>
  </body>
</html>
