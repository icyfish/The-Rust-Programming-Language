<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.36">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <title>Rust 程序设计语言</title><meta name="description" content="Translation of The Rust Programming Language">
    <link rel="modulepreload" href="/the-rust-programming-language/assets/app.b3a2ff78.js"><link rel="modulepreload" href="/the-rust-programming-language/assets/03-method-syntax.html.f99f831b.js"><link rel="modulepreload" href="/the-rust-programming-language/assets/03-method-syntax.html.94058cb0.js"><link rel="modulepreload" href="/the-rust-programming-language/assets/plugin-vue_export-helper.21dcd24c.js">
    <link rel="stylesheet" href="/the-rust-programming-language/assets/style.28c61a90.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header ref_key="navbar" class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/the-rust-programming-language/" class=""><!----><span class="site-name">Rust 程序设计语言</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a class="external-link" href="https://github.com/icyfish/the-rust-programming-language" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><form class="search-box" role="search"><input type="search" placeholder="搜索" autocomplete="off" spellcheck="false" value><!----></form></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a class="external-link" href="https://github.com/icyfish/the-rust-programming-language" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><a href="/the-rust-programming-language/ch01/00-getting-started.md" class="sidebar-item sidebar-heading" aria-label="1. 入门"><!--[--><!--]--> 1. 入门 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/the-rust-programming-language/ch01/01-installation.md" class="sidebar-item" aria-label="1.1 安装"><!--[--><!--]--> 1.1 安装 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/the-rust-programming-language/ch04/00-understanding-ownership.md" class="sidebar-item sidebar-heading" aria-label="4. 理解所有权"><!--[--><!--]--> 4. 理解所有权 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/the-rust-programming-language/ch04/01-what-is-ownership.md" class="sidebar-item" aria-label="4.1 什么是所有权"><!--[--><!--]--> 4.1 什么是所有权 <!--[--><!--]--></a><!----></li><li><a href="/the-rust-programming-language/ch04/02-references-and-borrowing.md" class="sidebar-item" aria-label="4.2 引用与借用"><!--[--><!--]--> 4.2 引用与借用 <!--[--><!--]--></a><!----></li><li><a href="/the-rust-programming-language/ch04/03-slices.md" class="sidebar-item" aria-label="4.3 Slice 类型"><!--[--><!--]--> 4.3 Slice 类型 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/the-rust-programming-language/ch05/00-structs.md" class="sidebar-item sidebar-heading active" aria-label="5. 使用结构体来组织相关联的数据"><!--[--><!--]--> 5. 使用结构体来组织相关联的数据 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/the-rust-programming-language/ch05/01-defining-structs.md" class="sidebar-item" aria-label="5.1 定义并实例化结构体"><!--[--><!--]--> 5.1 定义并实例化结构体 <!--[--><!--]--></a><!----></li><li><a href="/the-rust-programming-language/ch05/02-example-structs.md" class="sidebar-item" aria-label="5.2 使用结构体的示例程序"><!--[--><!--]--> 5.2 使用结构体的示例程序 <!--[--><!--]--></a><!----></li><li><a href="/the-rust-programming-language/ch05/03-method-syntax.md" class="sidebar-item active" aria-label="5.3 方法语法"><!--[--><!--]--> 5.3 方法语法 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/the-rust-programming-language/ch06/00-enums" class="sidebar-item sidebar-heading" aria-label="6. 枚举和模式匹配"><!--[--><!--]--> 6. 枚举和模式匹配 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/the-rust-programming-language/ch06/01-defining-an-enum" class="sidebar-item" aria-label="6.1 定义枚举"><!--[--><!--]--> 6.1 定义枚举 <!--[--><!--]--></a><!----></li><li><a href="/the-rust-programming-language/ch06/02-match" class="sidebar-item" aria-label="6.2 match 控制流结构体"><!--[--><!--]--> 6.2 match 控制流结构体 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><nav class="table-of-contents"><ul><li><a aria-current="page" href="/the-rust-programming-language/ch05/03-method-syntax.html#方法语法" class="router-link-active router-link-exact-active">方法语法</a><ul><li><a aria-current="page" href="/the-rust-programming-language/ch05/03-method-syntax.html#定义方法" class="router-link-active router-link-exact-active">定义方法</a></li><li><a aria-current="page" href="/the-rust-programming-language/ch05/03-method-syntax.html#当方法接受多个参数" class="router-link-active router-link-exact-active">当方法接受多个参数</a></li><li><a aria-current="page" href="/the-rust-programming-language/ch05/03-method-syntax.html#关联函数" class="router-link-active router-link-exact-active">关联函数</a></li><li><a aria-current="page" href="/the-rust-programming-language/ch05/03-method-syntax.html#多个-impl-块" class="router-link-active router-link-exact-active">多个 impl 块</a></li><li><a aria-current="page" href="/the-rust-programming-language/ch05/03-method-syntax.html#总结" class="router-link-active router-link-exact-active">总结</a></li></ul></li></ul></nav><ul><li><a href="https://doc.rust-lang.org/stable/book/ch05-03-method-syntax.html" target="_blank" rel="noopener noreferrer">Original Post: Method Syntax<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li></ul><h2 id="方法语法" tabindex="-1"><a class="header-anchor" href="#方法语法" aria-hidden="true">#</a> 方法语法</h2><p><strong>方法</strong>(<em>method</em>) 跟函数很像: 使用 <code>fn</code> 关键词和一个名称来声明, 同样接受参数和返回值, 并且当方法被调用时, 方法内部的代码会被执行. 不过和函数不同的是: 方法在结构体(或枚举, 或 trait 对象)的上下文中被定义. 关于枚举和 trait 对象, 我们分别会在第6章和第17章中进行详细的介绍. 通常情况下, 方法的第一个参数始终是 <code>self</code>, <code>self</code> 表示调用该方法的结构体实例.</p><h3 id="定义方法" tabindex="-1"><a class="header-anchor" href="#定义方法" aria-hidden="true">#</a> 定义方法</h3><p>现在我们修改接受 <code>Rectangle</code> 实例作为参数的函数 <code>area</code>, 将 <code>area</code> 改成 <code>Rectangle</code> 结构体的方法, 具体代码示例见5-13:</p><div class="language-rust ext-rs line-numbers-mode"><pre class="language-rust"><code><span class="token attribute attr-name">#[derive(Debug)]</span>
<span class="token keyword">struct</span> <span class="token type-definition class-name">Rectangle</span> <span class="token punctuation">{</span>
    width<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span>
    height<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">impl</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">area</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">u32</span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>width <span class="token operator">*</span> <span class="token keyword">self</span><span class="token punctuation">.</span>height
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> rect1 <span class="token operator">=</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>
        width<span class="token punctuation">:</span> <span class="token number">30</span><span class="token punctuation">,</span>
        height<span class="token punctuation">:</span> <span class="token number">50</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token macro property">println!</span><span class="token punctuation">(</span>
        <span class="token string">&quot;The area of the rectangle is {} square pixels.&quot;</span><span class="token punctuation">,</span>
        rect1<span class="token punctuation">.</span><span class="token function">area</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><p>为了在 <code>Rectangle</code> 上下文中定义方法, 我们要在 <code>Rectangle</code> 前添加 <code>impl</code> 块, impl 是 implementation(实现) 的缩写. 在 <code>impl</code> 块内部所定义的所有都会与 <code>Rectangle</code> 类型关联. 之后我们将 <code>area</code> 函数移动到 <code>impl</code> 之后的大括号中, 将第一个参数修改为 <code>self</code>, 同时修改函数体中对应的内容. 在 <code>main</code> 函数中, 我们调用了 <code>area</code> 函数并传递了 <code>rect1</code> 函数作为参数, 现在我们用方法语法来替代这部分内容, 改为调用 <code>Rectangle</code> 实例中的 <code>area</code> 方法. 具体方式是在实例后加 <code>.</code>, 并跟上方法名和括号, 括号中传入所需的参数.</p><p>在 <code>area</code> 签名中, 我们使用 <code>&amp;self</code> 而不是 <code>rectangle: &amp;Rectangle</code>. 实际上 <code>&amp;self</code> 是 <code>self: &amp;Self</code> 的简写. 在 <code>impl</code> 块中, <code>Self</code> 是 <code>impl</code> 所指代类型的别名. 方法的第一个参数名必须为 <code>self</code>, 其类型为 <code>Self</code>. 因此 Rust 强制我们在方法第一个参数的位置使用 <code>self</code> 作为参数名. 同时还要注意我们要在第一个参数 <code>self</code> 前加上 <code>&amp;</code>, 表示该方法借用了 <code>Self</code> 的实例, 这部分的行为与 <code>rectangle: &amp;Rectangle</code> 所表示的行为是一致的. 方法可以获取 <code>self</code> 的所有权, 以不可变的方式借用 <code>self</code>(我们目前的代码就是这样做的), 也可以以可变的方式借用 <code>self</code>, 和其他参数无异.</p><p>在这里我们选择使用 <code>&amp;self</code>, 和在函数的版本中选择 <code>&amp;Rectangle</code> 是基于同样的理由: 我们并不想要获取所有权, 只是单纯地想读取结构体中的数据而已, 并没有想要写入数据. 如果想要修改方法所对应的结构体实例, 就要使用 <code>&amp;mut self</code> 作为第一个参数. 一般情况下, 如果某个结构体的方法只接受 <code>self</code> 作为参数, 该方法的内部大概率不会想要获取结构体实例的所有权. 有种可能的使用场景是, 方法内部要将 <code>self</code> 转换成其它实例时, 我们希望避免在转换之后使用其它实例时, 误用了原始的实例.</p><p>使用方法而不是函数的主要原因, 除了提供方法语法和不需要在方法签名内部不断重复 <code>self</code> 的类型之外, 还有就是为了能够使代码组织性变得更强. 我们在 <code>impl</code> 块中列出了所有针对该类型的实例能够实现的功能, 这样一来, 别的开发者查看我们的代码时就不需要费力到各处去搜索 <code>Rectangle</code> 究竟有什么能力了.</p><p>对了, 对于方法名, 我们可以选择与字段名相同. 比如, 在 <code>Rectangle</code> 中, 存在 <code>width</code> 字段, 我们同样可以定义一个名为 <code>width</code> 的方法:</p><div class="language-rust ext-rs line-numbers-mode"><pre class="language-rust"><code><span class="token attribute attr-name">#[derive(Debug)]</span>
<span class="token keyword">struct</span> <span class="token type-definition class-name">Rectangle</span> <span class="token punctuation">{</span>
    width<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span>
    height<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">impl</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">width</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">bool</span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>width <span class="token operator">&gt;</span> <span class="token number">0</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> rect1 <span class="token operator">=</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>
        width<span class="token punctuation">:</span> <span class="token number">30</span><span class="token punctuation">,</span>
        height<span class="token punctuation">:</span> <span class="token number">50</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> rect1<span class="token punctuation">.</span><span class="token function">width</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;The rectangle has a nonzero width; it is {}&quot;</span><span class="token punctuation">,</span> rect1<span class="token punctuation">.</span>width<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>在上面的例子中, 我们的 <code>width</code> 方法实现了这样的功能: 如果实例的 <code>width</code> 字段值大于 0 的话, <code>width</code> 方法就返回 <code>true</code>, 如果值是 0 则返回 <code>false</code>: 在任何情况下我们都能在方法内使用与之同名的字段. 在 <code>main</code> 函数中, 当 Rust 发现我们在 <code>rect1.width</code> 之后加上括号, 就知道此时的 <code>width</code> 指的是方法. 如果后面没有跟上括号则是字段 <code>width</code>.</p><p>当我们在结构体中定义与字段同名的方法, 通常(但并不是所有时候)会是希望该方法只返回字段中的值, 而不做任何其他事情. 这样的方法被称为 <em>getters</em>, Rust 不像一些其他语言一样内置 getters, 我们必须手动实现. Getters 很有用, 我们可以将某个字段设置为私有, 同名方法为公开方法, 通过这样的方式设置字段的只读属性, 提供一个公开的 API 来读取该字段. 我们会在第七章对私有和公有的概念, 以及如何指定字段或方法为公有或者私有进行详细的介绍.</p><div class="custom-container tip"><p class="custom-container-title">-&gt; 运算符在哪里?</p><p>在 C 和 C++ 程序语言中, 调用方法有两种方式: 如果是直接调用对象上的方法, 可以直接用 <code>.</code> 运算符, 调用关联到对象的指针上的方法, 则是用 <code>-&gt;</code>, 并且此时还需要先对指针进行解引用(dereference). 换句话说, 如果 <code>object</code> 是一个指针, 那么 <code>object-&gt;something</code> 就类似 <code>(*object).something</code>.</p><p>Rust 中并没有与 <code>-&gt;</code> 运算符同样功能的运算符, 不过, Rust 中有个特性: <strong>自动引用和解引用</strong>(<em>automatic referencing and dereferencing</em>). 当我们调用结构体中的方法的时候, 就会发生自动引用和解引用的行为.</p><p>它内部是这样工作的: 当我们这样调用方法时: <code>object.something()</code>, Rust 会为 <code>object</code> 自动添加 <code>&amp;</code>, <code>&amp;mut</code>, 或者 <code>*</code>, 使得 <code>object</code> 能够匹配方法的签名. 也就是说, 以下两部分代码是一致的:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token comment">#![allow(unused)]</span>
fn <span class="token function-name function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token comment">#[derive(Debug,Copy,Clone)]</span>
struct Point <span class="token punctuation">{</span>
    x: f64,
    y: f64,
<span class="token punctuation">}</span>

impl Point <span class="token punctuation">{</span>
   fn distance<span class="token punctuation">(</span><span class="token operator">&amp;</span>self, other: <span class="token operator">&amp;</span>Point<span class="token punctuation">)</span> -<span class="token operator">&gt;</span> f64 <span class="token punctuation">{</span>
       <span class="token builtin class-name">let</span> x_squared <span class="token operator">=</span> f64::powi<span class="token punctuation">(</span>other.x - self.x, <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token builtin class-name">let</span> y_squared <span class="token operator">=</span> f64::powi<span class="token punctuation">(</span>other.y - self.y, <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

       f64::sqrt<span class="token punctuation">(</span>x_squared + y_squared<span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token builtin class-name">let</span> p1 <span class="token operator">=</span> Point <span class="token punctuation">{</span> x: <span class="token number">0.0</span>, y: <span class="token number">0.0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token builtin class-name">let</span> p2 <span class="token operator">=</span> Point <span class="token punctuation">{</span> x: <span class="token number">5.0</span>, y: <span class="token number">6.5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
p1.distance<span class="token punctuation">(</span><span class="token operator">&amp;</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span><span class="token operator">&amp;</span>p1<span class="token punctuation">)</span>.distance<span class="token punctuation">(</span><span class="token operator">&amp;</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>第一行的代码 <code>p1.distance(&amp;p2);</code> 看起来更简洁一些. 自动引用的行为之所以有效的原因是方法有一个明确的接收者 -- <code>self</code> 的类型. 只要知道了接收者和方法的名称, Rust 就能够区分出方法是在进行读取(<code>&amp;self</code>), 修改(<code>&amp;mut self</code>)还是获取所有权(<code>self</code>)的操作. Rust 对方法接收者的隐式借用使得所有权的功能在实践中更加好用.</p></div><h3 id="当方法接受多个参数" tabindex="-1"><a class="header-anchor" href="#当方法接受多个参数" aria-hidden="true">#</a> 当方法接受多个参数</h3><p>现在我们开始实现 <code>Rectangle</code> 结构体的第二个方法. 这一次, 我们要实现这样的操作: 让 <code>Rectangle</code> 的一个实例接收它的另一个实例, 如果如果第二个长方形能够完全被套入第一个长方形中的话, 就返回 <code>true</code>, 否则返回 <code>false</code>. 也就是说, 一旦我们定义了 <code>can_hold</code> 方法, 就能够编写以下示例 5-14 中的代码:</p><div class="language-rust ext-rs line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> rect1 <span class="token operator">=</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>
        width<span class="token punctuation">:</span> <span class="token number">30</span><span class="token punctuation">,</span>
        height<span class="token punctuation">:</span> <span class="token number">50</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> rect2 <span class="token operator">=</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>
        width<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span>
        height<span class="token punctuation">:</span> <span class="token number">40</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> rect3 <span class="token operator">=</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>
        width<span class="token punctuation">:</span> <span class="token number">60</span><span class="token punctuation">,</span>
        height<span class="token punctuation">:</span> <span class="token number">45</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;Can rect1 hold rect2? {}&quot;</span><span class="token punctuation">,</span> rect1<span class="token punctuation">.</span><span class="token function">can_hold</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rect2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;Can rect1 hold rect3? {}&quot;</span><span class="token punctuation">,</span> rect1<span class="token punctuation">.</span><span class="token function">can_hold</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rect3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>预期的输出结果大概会是下面这样, 因为 <code>rect2</code> 的宽高都比 <code>rect1</code> 小, 而 <code>rect3</code> 的宽度大于 <code>rect1</code> 的宽度:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>Can rect1 hold rect2? <span class="token boolean">true</span>
Can rect1 hold rect3? <span class="token boolean">false</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>因为我们想要定义一个方法, 所以应该在 <code>impl Rectangle</code> 块中定义. 方法名为 <code>can_hold</code>, 并且该方法接收另一个 <code>Rectangle</code> 的不可变借用作为参数. 通过查看调用该方法的代码, 我们可以区分出参数的类型: <code>rect1.can_hold(&amp;rect2)</code> 传入的参数是 <code>&amp;rect2</code>, 它是 <code>Rectangle</code> 其中一个实例 <code>rect2</code> 的不可变借用. 此时使用不可变借用比较合理, 因为我们只需要读取 <code>rect2</code>(并不需要写入, 如果是写入的话, 就应该使用可变借用), 同时我们希望 <code>main</code> 函数持续拥有 <code>rect2</code> 的所有权, 以便在调用 <code>can_hold</code> 方法之后依然能够使用它. <code>can_hold</code> 方法的返回值类型是布尔值, 其内部实现的功能是: 检查 <code>self</code> 的宽高值是否大于 <code>Rectangle</code> 另一个实例的对应宽度和高度值. 现在我们在代码5-13中的 <code>impl</code> 块中添加 <code>can_hold</code> 方法的实现, 具体代码示例为下面的 5-15:</p><div class="language-rust ext-rs line-numbers-mode"><pre class="language-rust"><code><span class="token attribute attr-name">#[derive(Debug)]</span>
<span class="token keyword">struct</span> <span class="token type-definition class-name">Rectangle</span> <span class="token punctuation">{</span>
    width<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span>
    height<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">impl</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">area</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">u32</span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>width <span class="token operator">*</span> <span class="token keyword">self</span><span class="token punctuation">.</span>height
    <span class="token punctuation">}</span>

    <span class="token keyword">fn</span> <span class="token function-definition function">can_hold</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> other<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Rectangle</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">bool</span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>width <span class="token operator">&gt;</span> other<span class="token punctuation">.</span>width <span class="token operator">&amp;&amp;</span> <span class="token keyword">self</span><span class="token punctuation">.</span>height <span class="token operator">&gt;</span> other<span class="token punctuation">.</span>height
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> rect1 <span class="token operator">=</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>
        width<span class="token punctuation">:</span> <span class="token number">30</span><span class="token punctuation">,</span>
        height<span class="token punctuation">:</span> <span class="token number">50</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> rect2 <span class="token operator">=</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>
        width<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span>
        height<span class="token punctuation">:</span> <span class="token number">40</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> rect3 <span class="token operator">=</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>
        width<span class="token punctuation">:</span> <span class="token number">60</span><span class="token punctuation">,</span>
        height<span class="token punctuation">:</span> <span class="token number">45</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;Can rect1 hold rect2? {}&quot;</span><span class="token punctuation">,</span> rect1<span class="token punctuation">.</span><span class="token function">can_hold</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rect2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;Can rect1 hold rect3? {}&quot;</span><span class="token punctuation">,</span> rect1<span class="token punctuation">.</span><span class="token function">can_hold</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rect3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br></div></div><p>实现了 <code>can_hold</code> 方法之后, 当我们执行5-14中的代码, 就能够得到预期的结果. 方法能够接受多个参数, 这些参数都紧接在 <code>self</code> 参数之后, 这些参数与普通的函数参数的功能并没有区别.</p><h3 id="关联函数" tabindex="-1"><a class="header-anchor" href="#关联函数" aria-hidden="true">#</a> 关联函数</h3><p>如果函数被定义在 <code>impl</code> 块中, 则该函数就是 <em>关联函数</em>. 之所以被称为关联函数, 是因为这些函数与 <code>impl</code> 之后的类型声明相关联. 我们可以定义一个关联函数, 但不以 <code>self</code> 作为第一个参数, 因此该关联函数也不是方法, 因为他们不需要与结构体的实例共同作用. 之前我们已经使用过 <code>String::from</code> 这类函数, 其中 <code>from</code> 方法定义在 <code>String</code> 类型上.</p><p>关联函数并非方法, 因此常被作为返回一个结构体实例的构造器. 举个例子, 我们可以定义一个关联函数, 接受一个参数, 这个参数能同时作为长方形的宽和高, 这样能更容易地创建正方形, 而不需要声明同一个值两次:</p><div class="language-rust ext-rs line-numbers-mode"><pre class="language-rust"><code><span class="token attribute attr-name">#[derive(Debug)]</span>
<span class="token keyword">struct</span> <span class="token type-definition class-name">Rectangle</span> <span class="token punctuation">{</span>
    width<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span>
    height<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">impl</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">square</span><span class="token punctuation">(</span>size<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>
        <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>
            width<span class="token punctuation">:</span> size<span class="token punctuation">,</span>
            height<span class="token punctuation">:</span> size<span class="token punctuation">,</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> sq <span class="token operator">=</span> <span class="token class-name">Rectangle</span><span class="token punctuation">::</span><span class="token function">square</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>如果要调用关联函数, 我们可以使用 <code>::</code> 语法, 其后跟上结构体的名称; 比如: <code>let sq = Rectangle::square(3);</code>. 这个方法在结构体的命名空间中: <code>::</code> 语法能同时作用于关联函数和模块所创建的命名空间中. 我们会在第七章中讨论模块的概念.</p><h3 id="多个-impl-块" tabindex="-1"><a class="header-anchor" href="#多个-impl-块" aria-hidden="true">#</a> 多个 <code>impl</code> 块</h3><p>每个结构体都允许存在多个 <code>impl</code> 块. 比如, 代码示例 5-15 与 5-16 是一致的, 只是在 5-16 中, 方法都声明在 <code>impl</code> 块中:</p><p>(5-16: 使用 <code>impl</code> 块重写 5-15 的代码)</p><div class="language-rust ext-rs line-numbers-mode"><pre class="language-rust"><code><span class="token attribute attr-name">#[derive(Debug)]</span>
<span class="token keyword">struct</span> <span class="token type-definition class-name">Rectangle</span> <span class="token punctuation">{</span>
    width<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span>
    height<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">impl</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">area</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">u32</span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>width <span class="token operator">*</span> <span class="token keyword">self</span><span class="token punctuation">.</span>height
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">impl</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function-definition function">can_hold</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> other<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">Rectangle</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token keyword">bool</span> <span class="token punctuation">{</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>width <span class="token operator">&gt;</span> other<span class="token punctuation">.</span>width <span class="token operator">&amp;&amp;</span> <span class="token keyword">self</span><span class="token punctuation">.</span>height <span class="token operator">&gt;</span> other<span class="token punctuation">.</span>height
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> rect1 <span class="token operator">=</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>
        width<span class="token punctuation">:</span> <span class="token number">30</span><span class="token punctuation">,</span>
        height<span class="token punctuation">:</span> <span class="token number">50</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> rect2 <span class="token operator">=</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>
        width<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span>
        height<span class="token punctuation">:</span> <span class="token number">40</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> rect3 <span class="token operator">=</span> <span class="token class-name">Rectangle</span> <span class="token punctuation">{</span>
        width<span class="token punctuation">:</span> <span class="token number">60</span><span class="token punctuation">,</span>
        height<span class="token punctuation">:</span> <span class="token number">45</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;Can rect1 hold rect2? {}&quot;</span><span class="token punctuation">,</span> rect1<span class="token punctuation">.</span><span class="token function">can_hold</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rect2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;Can rect1 hold rect3? {}&quot;</span><span class="token punctuation">,</span> rect1<span class="token punctuation">.</span><span class="token function">can_hold</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rect3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><p>在这里我们没有必要将两个方法分别用 <code>impl</code> 块包裹, 以上示例只是想表明这是个合法的语法. 在第 10 章中我们会介绍泛型和 trait 的概念, 也会看到多个 <code>impl</code> 块的实际使用场景.</p><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h3><p>运用结构体, 我们可以创建自定义的类型, 保持相关的数据互相关联, 使得代码更加清晰. 在 <code>impl</code> 块中, 可以定义与类型相关的函数, 同时, 方法也是关联函数的其中一种类型, 使得我们能够声明结构体实例的行为.</p><p>不过结构体并不是创建自定义类型的唯一方式: Rust 的枚举功能也能帮助我们达到相同的目的.</p><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: icyyfish@gmail.com">Fish</span><!--[-->, <!--]--><!--]--><!--[--><span class="contributor" title="email: icyyfish@gmail.com">icyfish</span><!----><!--]--><!--]--></span></div></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/the-rust-programming-language/assets/app.b3a2ff78.js" defer></script>
  </body>
</html>
