<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.36">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <title>Rust 程序设计语言</title><meta name="description" content="Translation of The Rust Programming Language">
    <link rel="modulepreload" href="/the-rust-programming-language/assets/app.b3a2ff78.js"><link rel="modulepreload" href="/the-rust-programming-language/assets/01-what-is-ownership.html.7ae2efce.js"><link rel="modulepreload" href="/the-rust-programming-language/assets/01-what-is-ownership.html.b87abcb8.js"><link rel="modulepreload" href="/the-rust-programming-language/assets/plugin-vue_export-helper.21dcd24c.js">
    <link rel="stylesheet" href="/the-rust-programming-language/assets/style.28c61a90.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header ref_key="navbar" class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/the-rust-programming-language/" class=""><!----><span class="site-name">Rust 程序设计语言</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a class="external-link" href="https://github.com/icyfish/the-rust-programming-language" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><form class="search-box" role="search"><input type="search" placeholder="搜索" autocomplete="off" spellcheck="false" value><!----></form></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a class="external-link" href="https://github.com/icyfish/the-rust-programming-language" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><a href="/the-rust-programming-language/ch01/00-getting-started.md" class="sidebar-item sidebar-heading" aria-label="1. 入门"><!--[--><!--]--> 1. 入门 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/the-rust-programming-language/ch01/01-installation.md" class="sidebar-item" aria-label="1.1 安装"><!--[--><!--]--> 1.1 安装 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/the-rust-programming-language/ch04/00-understanding-ownership.md" class="sidebar-item sidebar-heading active" aria-label="4. 理解所有权"><!--[--><!--]--> 4. 理解所有权 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/the-rust-programming-language/ch04/01-what-is-ownership.md" class="sidebar-item active" aria-label="4.1 什么是所有权"><!--[--><!--]--> 4.1 什么是所有权 <!--[--><!--]--></a><!----></li><li><a href="/the-rust-programming-language/ch04/02-references-and-borrowing.md" class="sidebar-item" aria-label="4.2 引用与借用"><!--[--><!--]--> 4.2 引用与借用 <!--[--><!--]--></a><!----></li><li><a href="/the-rust-programming-language/ch04/03-slices.md" class="sidebar-item" aria-label="4.3 Slice 类型"><!--[--><!--]--> 4.3 Slice 类型 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/the-rust-programming-language/ch05/00-structs.md" class="sidebar-item sidebar-heading" aria-label="5. 使用结构体来组织相关联的数据"><!--[--><!--]--> 5. 使用结构体来组织相关联的数据 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/the-rust-programming-language/ch05/01-defining-structs.md" class="sidebar-item" aria-label="5.1 定义并实例化结构体"><!--[--><!--]--> 5.1 定义并实例化结构体 <!--[--><!--]--></a><!----></li><li><a href="/the-rust-programming-language/ch05/02-example-structs.md" class="sidebar-item" aria-label="5.2 使用结构体的示例程序"><!--[--><!--]--> 5.2 使用结构体的示例程序 <!--[--><!--]--></a><!----></li><li><a href="/the-rust-programming-language/ch05/03-method-syntax.md" class="sidebar-item" aria-label="5.3 方法语法"><!--[--><!--]--> 5.3 方法语法 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/the-rust-programming-language/ch06/00-enums" class="sidebar-item sidebar-heading" aria-label="6. 枚举和模式匹配"><!--[--><!--]--> 6. 枚举和模式匹配 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/the-rust-programming-language/ch06/01-defining-an-enum" class="sidebar-item" aria-label="6.1 定义枚举"><!--[--><!--]--> 6.1 定义枚举 <!--[--><!--]--></a><!----></li><li><a href="/the-rust-programming-language/ch06/02-match" class="sidebar-item" aria-label="6.2 match 控制流结构体"><!--[--><!--]--> 6.2 match 控制流结构体 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><nav class="table-of-contents"><ul><li><a aria-current="page" href="/the-rust-programming-language/ch04/01-what-is-ownership.html#_4-1-什么是所有权" class="router-link-active router-link-exact-active">4.1 什么是所有权</a><ul><li><a aria-current="page" href="/the-rust-programming-language/ch04/01-what-is-ownership.html#所有权的规则" class="router-link-active router-link-exact-active">所有权的规则</a></li><li><a aria-current="page" href="/the-rust-programming-language/ch04/01-what-is-ownership.html#变量的作用域" class="router-link-active router-link-exact-active">变量的作用域</a></li><li><a aria-current="page" href="/the-rust-programming-language/ch04/01-what-is-ownership.html#string-类型" class="router-link-active router-link-exact-active">String 类型</a></li><li><a aria-current="page" href="/the-rust-programming-language/ch04/01-what-is-ownership.html#内存与分配" class="router-link-active router-link-exact-active">内存与分配</a></li><li><a aria-current="page" href="/the-rust-programming-language/ch04/01-what-is-ownership.html#变量和数据交互的方式-移动" class="router-link-active router-link-exact-active">变量和数据交互的方式: 移动</a></li><li><a aria-current="page" href="/the-rust-programming-language/ch04/01-what-is-ownership.html#变量和数据交互的方式-克隆" class="router-link-active router-link-exact-active">变量和数据交互的方式: 克隆</a></li><li><a aria-current="page" href="/the-rust-programming-language/ch04/01-what-is-ownership.html#只存储在栈上的数据-拷贝" class="router-link-active router-link-exact-active">只存储在栈上的数据: 拷贝</a></li><li><a aria-current="page" href="/the-rust-programming-language/ch04/01-what-is-ownership.html#所有权和函数" class="router-link-active router-link-exact-active">所有权和函数</a></li><li><a aria-current="page" href="/the-rust-programming-language/ch04/01-what-is-ownership.html#返回值和作用域" class="router-link-active router-link-exact-active">返回值和作用域</a></li></ul></li></ul></nav><h2 id="_4-1-什么是所有权" tabindex="-1"><a class="header-anchor" href="#_4-1-什么是所有权" aria-hidden="true">#</a> 4.1 什么是所有权</h2><p><strong>所有权</strong>(<em>ownership</em>)是 Rust 程序管理内存的一系列规则. 所有程序在执行时都需要对计算机的内存进行控制. 有些编程语言中存在垃圾回收机制, 当程序运行时会不断寻找未被使用的内存, 而在某些其它编程语言中, 开发者必须自己去操作分配和释放内存. Rust 使用的是第三种方式: 内存通过所有权系统以及编译器的一系列规则被管理. 如果任何规则被打破, 程序就不会被成功编译. 可以放心的是, 所有权的相关功能执行不会拖慢程序运行的速度.</p><p>因为所有权对许多开发者来说是一个全新的概念, 所以需要花时间进行了解. 好消息是, 当我们对 Rust 的使用经验更丰富, 对所有权系统的规则越熟悉之后, 就能够更容易地写出安全有效的代码.</p><p>当我们理解了所有权的概念之后, 就会对 Rust 中的许多特性有更深刻的理解, 也正是这些特性使得 Rust 在一众编程语言中变得特别. 本章我们会通过一些示例来学习所有权的概念, 这些示例都围绕一个很常见的数据结构: <code>string</code> 展开.</p><div class="custom-container tip"><p class="custom-container-title">栈和堆</p><p>在一些编程语言中, 我们无需考虑堆栈的概念. 但是在像 Rust 这样的系统编程语言中, 值被存储在栈中还是堆中, 对语言的行为有比较大的影响, 同时也会左右开发者如何去编写代码. 本章中关于所有权的一部分阐释, 会与堆栈的概念有所关联, 因此我们会事先对堆和栈进行简单的介绍.</p><p>栈和堆都是内存的一部分, 当我们的代码在运行时, 都会用到它们, 不过两者的结构有所不同. 我们按顺序在栈中存储数据, 然后以相反的顺序取出这些数据. 这个行为被称作是: <strong>后进先出</strong> (<em>last in, first out</em>). 想象一叠盘子, 当我们要添加更多盘子时, 会将它们置于顶部, 取出时也是从顶部取出. 添加和取出的操作都必须在顶部完成, 在中间或者底部都是无效的. 添加数据的行为被称作是: <strong>进栈</strong> (<em>pushing onto the stack</em>), 取出数据的行为则是: <strong>出栈</strong> (<em>popping off the stack</em>). 所有存在栈中的数据都需要有一个已知, 固定的大小. 如果数据的大小在编译阶段是未知或者实时可变的, 就应该存储在堆中.</p><p>堆相比栈来说, 组织性更差. 当我们在堆中存储数据的时候, 需要请求特定大小的空间. 内存分配工具会在堆中找一个尽可能大的未被使用的空间, 将其标志为已使用, 并返回一个 <strong>指针</strong>(<em>pointer</em>), 表示该空间的具体位置. 这个过程叫做: <strong>在堆中分配内存</strong> (<em>allocating on the heap</em>), 有时候被简称为 <strong>分配</strong> (<em>allocating</em>). 存储数据到栈中的操作不是分配. 由于指向堆的指针大小已知且固定, 因此指针可以被存储在栈中, 不过当我们需要实际的数据时, 就要去访问指针. 想象我们在餐厅就餐, 进入餐厅时我们会事先说明就餐人数, 之后服务员会带大家去到合适的空桌中. 如果某个人迟到了, 他也可以通过咨询找到目标位置.</p><p>入栈比在堆中分配内存的速度更快, 因为在入栈的操作中, 内存分配器不需要去搜索实际数据存储在哪里, 存储的位置始终是栈顶. 同时两者相比, 在堆中分配内存需要更多的工作, 因为分配器首先要找到一个足够大的空间来存储数据, 然后进行一些记录, 为下一次分配做准备. 从堆中获取数据比从栈中获取数据更慢, 因为首先要访问指针. 对于现代处理器来说, 在内存中跳转频次越少, 处理速度就越快. 继续同样的类比, 想象餐厅服务员要处理多个餐桌的点单. 最有效的方式是在一个餐桌中获取完成所有点单之后再去到下一个餐桌. 如果从餐桌 A 获取一部分点单之后, 又去到餐桌 B 获取一部分点单, 然后返回 A 继续获取点单, 接着去 B 餐桌, 这样的过程就会很慢很繁琐. 因此同样地, 当处理器需要处理的数据与其他数据位置比较近的时候, 处理器的工作就能更高效. 分配堆中的一大部分空间也会消耗比较多的时间.</p><p>当我们的代码调用一个函数时, 值被传入函数中(这个值也可能包括指向堆中数据的指针), 并且函数内部的变量被压入栈中. 当函数执行结束, 这些值又被移出栈.</p><p>记录哪部分代码在使用堆中哪部分的数据, 尽量减少在堆中存储重复的数据, 清除堆中未被使用的数据, 避免使用太多的空间, 这些都是所有权需要处理的问题. 不过一旦你理解了所有权的概念, 你就不需要考虑太多堆和栈了. 了解所有权的最主要目的是处理堆数据, 能够帮助我们更好地理解所有权的工作机制.</p></div><h3 id="所有权的规则" tabindex="-1"><a class="header-anchor" href="#所有权的规则" aria-hidden="true">#</a> 所有权的规则</h3><p>首先我们来看看所有权的规则. 记住这些规则, 因为在我们使用示例阐述所有权概念的时候会用到:</p><ul><li>在 Rust 中, 每一个值都存在一个对应的变量, 这个变量叫做 <strong>所有者</strong> (<em>owner</em>).</li><li>一个值在一个时间段内只能存在一个所有者.</li><li>当所有者离开作用域之后, 该值也同时被丢弃.</li></ul><h3 id="变量的作用域" tabindex="-1"><a class="header-anchor" href="#变量的作用域" aria-hidden="true">#</a> 变量的作用域</h3><p>现在我们已经了解了 Rust 的基本语法, 在后续的代码示例中, 就不会再添加 <code>fn main() {</code> 这部分代码了, 因此需要注意在仿照示例时, 确保你的代码中添加了这部分代码. 这样做的原因是能够使得我们的示例代码更加简洁, 我们只需要关注应该关注的细节就可以, 不需要理会对于阐释没有帮助的部分.</p><p>在第一个所有权例子中, 我们关注一些变量的<code>作用域</code>. 作用域指的是: 一个项(item)在程序中有效的范围. 查看以下示例:</p><div class="language-rust ext-rs line-numbers-mode"><pre class="language-rust"><code><span class="token attribute attr-name">#![allow(unused)]</span>
<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>变量 <code>s</code> 绑定到了一个字符串字面量值, 这个字符串值被硬编码进了我们的程序代码中. 该变量从开始声明直到当前 <em>作用域</em> 结束, 都是有效的. 代码示例(4-1)中的注释说明了变量 <code>s</code> 在程序的哪个位置是有效的.</p><div class="language-rust ext-rs line-numbers-mode"><pre class="language-rust"><code><span class="token attribute attr-name">#![allow(unused)]</span>
<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">{</span>                      <span class="token comment">// s 还未被声明, 因此在这里不合法 </span>
        <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">;</span>   <span class="token comment">// s 在这里开始合法</span>

        <span class="token comment">// 可以在这里开始对 s 进行操作</span>
    <span class="token punctuation">}</span>                      <span class="token comment">// 作用域结束, s 不再合法</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>换句话说, 这里有两个重要的时间点:</p><ul><li>当 <code>s</code> 进入作用域之后, 它就合法了.</li><li>这一过程持续直到当前作用域结束.</li></ul><p>在这种情况下, 作用域和变量的关联关系和在其他编程语言上无异. 现在我们开始通过 <code>String</code> 类型的示例来理解这个概念.</p><h3 id="string-类型" tabindex="-1"><a class="header-anchor" href="#string-类型" aria-hidden="true">#</a> <code>String</code> 类型</h3><p>为了更好地说明所有权的概念, 我们需要一种比第三章的<a href="https://doc.rust-lang.org/book/ch03-02-data-types.html#data-types" target="_blank" rel="noopener noreferrer">&quot;数据类型&quot;<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>部分中讲到的更复杂的数据类型. 之前我们提到的数据类型都是已知大小的, 可以被存储在栈中, 当作用域结束之后又被弹出栈. 如果代码的另一部分需要在不同的作用域使用相同的值, 这类数据类型能够被迅速且轻易地复制以创建一个独立的实例. 但现在我们要开始把目光放在存储在堆中的数据, 探究 Rust 如何知道何时要清除这些数据, <code>String</code> 类型的数据就很适合用来进行阐述.</p><p>我们会重点关注 <code>String</code> 中与所有权相关的部分. 这些部分在其他复杂类型中同样适用, 无论是语言本身内置的复杂类型, 还是用户自己创建的复杂类型. 在<a href="https://doc.rust-lang.org/book/ch08-02-strings.html" target="_blank" rel="noopener noreferrer">第 8 章<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>中我们还会深入探讨 <code>String</code> 类型.</p><p>我们之前已经了解过字符串字面量, 也就是被硬编码到程序中的字符串值. 字符串字面量使用很方便, 但是并不适合所有使用文本的场景. 一个原因是字符串字面量不可变. 另一个原因是当我们在编写程序时, 并不一定每次都预先知道字符串的值是什么, 举个例子: 保存用户输入的字符串. 对于这些场景, Rust 会使用另一种字符串类型: <code>String</code> 来处理. 这种类型用以处理分配在堆中的数据, 并且能够存储在编译阶段未知大小的文本数据. 我们可以使用 <code>String</code> 提供的 <code>from</code> 方法基于字符串字面量来创建这种类型的字符串数据, 如:</p><div class="language-rust ext-rs line-numbers-mode"><pre class="language-rust"><code>
<span class="token attribute attr-name">#![allow(unused)]</span>
<span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>两个冒号所表示的运算符 <code>::</code> 使得我们能够直接使用 <code>String</code> 类型的命名空间下特定的方法 <code>from</code>, 而不需要使用另一种类似 <code>string_from</code> 的名称. 在第五章的<a href="https://doc.rust-lang.org/book/ch05-03-method-syntax.html#method-syntax" target="_blank" rel="noopener noreferrer">&quot;方法语法&quot;<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>部分, 我们会对这种语法进行更深入的探讨, 而在第七章的<a href="https://doc.rust-lang.org/book/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html" target="_blank" rel="noopener noreferrer">&quot;用于引用模块树中项的路径&quot;<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>, 我们则会探讨模块的命名空间.</p><p>这种类型的字符串是可变的:</p><div class="language-rust ext-rs line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token keyword">mut</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    s<span class="token punctuation">.</span><span class="token function">push_str</span><span class="token punctuation">(</span><span class="token string">&quot;, world!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// push_str() 方法将字符串字面量添加到 String 中</span>

    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{}&quot;</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 `hello, world!`</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>这里有什么不一样呢? 为什么 <code>String</code> 类型可变但是字符串字面量不可以呢? 区别是这两种类型数据在内存中存储的方式.</p><h3 id="内存与分配" tabindex="-1"><a class="header-anchor" href="#内存与分配" aria-hidden="true">#</a> 内存与分配</h3><p>对于字符串字面量, 我们在编译阶段就知道它的具体内容, 因此这些文本直接被硬编码到最后的执行文件中. 这也是为什么字符串字面量处理起来更快更有效的原因. 这些特性都来源于字符串的不可变特性. 不幸的是, 我们没有办法为了每一个在编译阶段大小未知的文本而将一块内存放入二进制文件中, 而且这些文本的大小还有可能随着程序的执行而变化.</p><p>对于 <code>String</code> 类型, 为了支持文本本身可变性和大小可变性, 我们需要在堆中分配一块编译阶段未知的内存来存储这些内容. 这意味着:</p><ul><li>必须在运行时向内存分配器请求内存.</li><li>当我们处理完 <code>String</code> 之后, 需要能够将内存返回给分配器.</li></ul><p>第一部分是要开发者自己实现的: 当我们调用 <code>String::from</code> 的时候, 方法本身就会请求它所需的内存. 这在编程语言中很常见.</p><p>然而, 第二部分的工作在不同的编程语言中则各有不同. 在存在<strong>垃圾回收器</strong>(<em>garbage collector(GC)</em>)的编程语言中, 垃圾回收器会不断搜索并回收未被占用的内存, 开发者不需要考虑太多. 在大部分不存在 GC 的语言中, 考虑释放内存的任务就到了开发者的身上了. 但一直以来, 处理内存的问题对开发者来说都比较困难, 如果我们忘记处理, 就会浪费内存. 如果太快释放内存则程序就会出现一个不合法变量. 重复操作也会导致 bug. 每一次分配 (<code>allocate</code>) 操作都对应一个释放 (<code>free</code>) 的操作.</p><p>Rust 所采用的是另外一种完全不同的方式: 当变量离开当前作用域之后, 内存就会自动被释放. 下面是我们使用 <code>String</code> 而非字符串字面量的代码示例:</p><div class="language-rust ext-rs line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// s 在这里开始被声明</span>
        <span class="token comment">// 我们能够使用 s</span>
    <span class="token punctuation">}</span>                                  <span class="token comment">// 作用域在此结束, s不再合法</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><code>s</code> 所占用的内存被释放的位置十分自然: 当 <code>s</code> 离开作用域的时候. 当一个变量离开作用域, Rust 就会为我们调用一个特别的函数. 这个函数是 <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html#tymethod.drop" target="_blank" rel="noopener noreferrer"><code>drop</code><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>, 在这里, 我们可以释放 <code>String</code> 对应的变量所占用的内存. 在函数体最后, Rust 自动调用 <code>drop</code> 方法.</p><blockquote><p>注意: 在 C++ 中, 在某个项目的生命周期结束释放内存的模式被称作是: <strong>资源获取即为初始化</strong>(<em>RAII</em>). 如果你了解过这个模式, 那么对 Rust 中的 <code>drop</code> 函数也不会太陌生.</p></blockquote><p>这个模式深刻地影响了 Rust 代码的编写方式. 现在看可能会觉得很简单, 但是在复杂场景下, 比如在堆中分配多个变量, 我们就很难预估代码的行为. 现在我们开始探索复杂场景:</p><h3 id="变量和数据交互的方式-移动" tabindex="-1"><a class="header-anchor" href="#变量和数据交互的方式-移动" aria-hidden="true">#</a> 变量和数据交互的方式: 移动</h3><p>在 Rust 中, 多个变量与相同的数据交互, 有多种方式. 现在我们看一个使用整型的代码示例(4-2):</p><div class="language-rust ext-rs line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>我们大概能够猜到以上的代码做了什么: 绑定值 <code>5</code> 到变量 <code>x</code> 中; 然后创建这个值的拷贝, 将拷贝绑定到 <code>y</code> 中. 现在我们有了两个变量: <code>x</code> 和 <code>y</code>, 并且它们的值都是 <code>5</code>. 真实情况也是这样, 因为整型是简单的变量类型, 而且大小已知, 因此这两个值都被推到了栈中.</p><p>现在我们看, 如果是 <code>String</code> 类型的变量, 会发生什么:</p><div class="language-rust ext-rs line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> s2 <span class="token operator">=</span> s1<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>以上两个示例看起来很像, 我们或许会在直觉上认为内部发生了同样的事情, 第二行的代码进行了拷贝值的操作. 但是实际上并不是这样.</p><p>看图表4-1可以发现实际上发生了什么. <code>String</code> 由三部分组成(下图左), 指向值所在内存区域的指针, 长度, 以及容量. 这一组数据存储在栈中. 右边则是存放在堆中的具体值.</p><p><img src="/the-rust-programming-language/images/trpl04-01.svg" alt="4-1"></p><p>长度表示 <code>String</code> 的内容当前使用了多少字节的内存. 容量则是分配器给 <code>String</code> 分配了多少字节的内存. 了解长度与容量的区别十分重要, 但是在我们目前的场景下, 可以忽略容量.</p><p>当我们将 <code>s1</code> 赋值给 <code>s2</code>, <code>String</code> 数据被拷贝, 但其实拷贝的只是存储在栈中的指针, 长度和容量, 并没有拷贝存储在堆中的真实数据. <code>s1</code>, <code>s2</code> 的内容是下图(4-2)这样的:</p><p><img src="/the-rust-programming-language/images/trpl04-02.svg" alt="4-2"></p><p>数据的表示并非如图(4-3), 如果是下图这样的话, 那么 <code>s2 = s1</code> 的操作, 在内容比较大的情况下就很消耗性能.</p><p><img src="/the-rust-programming-language/images/trpl04-03.svg" alt="4-3"></p><p>早先, 我们说到当变量离开作用域之后, Rust 就会自动调用 <code>drop</code> 函数, 同时为变量清理堆中的内存. 但是图表(4-2)却显示两部分的指针都指向同样的位置. 这时问题就来了, 当 <code>s1</code> 和 <code>s2</code> 离开作用域的时候, 它们都会试图释放同一块内存区域. 用专业术语描述就是: <strong>二次释放</strong> <em>(double free)</em> 错误, 也是我们先前提到过的内存安全性 bug 之一. 重复释放内存的操作会导致内存污染, 导致潜在的安全性问题.</p><p>为了确保内存的安全, <code>let s2 = s1</code> 这行代码执行结束之后, Rust 会将 <code>s1</code> 置为无效. 这样的话, 当 <code>s1</code> 离开当前作用域, Rust 就不需要考虑释放内存. 当你试图在 <code>s2</code> 创建之后使用 <code>s1</code>, 不会正常工作:</p><div class="language-rust ext-rs line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> s2 <span class="token operator">=</span> s1<span class="token punctuation">;</span>

    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{}, world!&quot;</span><span class="token punctuation">,</span> s1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>以上代码会报出异常, 因为 Rust 会阻止我们使用不合法的引用:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ cargo run
   Compiling ownership v0.1.0 <span class="token punctuation">(</span>file:///projects/ownership<span class="token punctuation">)</span>
error<span class="token punctuation">[</span>E0382<span class="token punctuation">]</span>: borrow of moved value: <span class="token variable"><span class="token variable">`</span>s1<span class="token variable">`</span></span>
 --<span class="token operator">&gt;</span> src/main.rs:5:28
  <span class="token operator">|</span>
<span class="token number">2</span> <span class="token operator">|</span>     <span class="token builtin class-name">let</span> s1 <span class="token operator">=</span> String::from<span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token operator">|</span>         -- move occurs because <span class="token variable"><span class="token variable">`</span>s1<span class="token variable">`</span></span> has <span class="token builtin class-name">type</span> <span class="token variable"><span class="token variable">`</span>String<span class="token variable">`</span></span>, <span class="token function">which</span> does not implement the <span class="token variable"><span class="token variable">`</span>Copy<span class="token variable">`</span></span> trait
<span class="token number">3</span> <span class="token operator">|</span>     <span class="token builtin class-name">let</span> s2 <span class="token operator">=</span> s1<span class="token punctuation">;</span>
  <span class="token operator">|</span>              -- value moved here
<span class="token number">4</span> <span class="token operator">|</span> 
<span class="token number">5</span> <span class="token operator">|</span>     println<span class="token operator">!</span><span class="token punctuation">(</span><span class="token string">&quot;{}, world!&quot;</span>, s1<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token operator">|</span>                            ^^ value borrowed here after move

For <span class="token function">more</span> information about this error, try <span class="token variable"><span class="token variable">`</span>rustc --explain E0382<span class="token variable">`</span></span><span class="token builtin class-name">.</span>
error: could not compile <span class="token variable"><span class="token variable">`</span>ownership<span class="token variable">`</span></span> due to previous error
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>如果你在其它编程语言中听过 <strong>浅拷贝</strong> (<em>shallow copy</em>) 和 <strong>深拷贝</strong> (<em>deep copy</em>), 拷贝指针, 长度和容量, 不拷贝值本身的行为和浅拷贝听起来很类似. 但是因为 Rust 同样也将第一个变量置为无效了, 所以并没有把这个行为定义为浅拷贝, 而是 <strong>移动</strong>(<em>move</em>). 在本例中, <code>s1</code>(的值)被移动到了 <code>s2</code>. 如图4-4:</p><p><img src="/the-rust-programming-language/images/trpl04-04.svg" alt="4-4"></p><p>这就解决了我们的问题. 由于只有 <code>s2</code> 是合法的, 当它离开作用域的时候, 只有 <code>s2</code> 所占用的内存被释放.</p><p>除此之外, 这里还暗含了一个 Rust 内部的设计意图: Rust 不可能会自动对数据进行深拷贝. 因此, 任何<strong>自动拷贝</strong>的操作对性能的影响都并不大.</p><h3 id="变量和数据交互的方式-克隆" tabindex="-1"><a class="header-anchor" href="#变量和数据交互的方式-克隆" aria-hidden="true">#</a> 变量和数据交互的方式: 克隆</h3><p>如果我们不仅想拷贝<code>String</code>所对应的栈中的数据, 还想拷贝堆中的实际数据, 可以用一个公用方法 <code>clone</code>. 在第五章中我们会讨论方法的语法. 但是由于方法在许多编程语言中是比较常见的特性, 你应该在之前就已经了解过.</p><p>下面是 <code>clone</code> 方法的一个实际例子:</p><div class="language-rust ext-rs line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> s2 <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;s1 = {}, s2 = {}&quot;</span><span class="token punctuation">,</span> s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>以上的代码就能够正常工作, 并且行为和图表4-3所表示的一致, 堆中的数据被拷贝.</p><p>当调用 <code>clone</code> 时, 某些代码确实被执行且对性能有较大的损耗, 也能够通过 <code>clone</code> 看出来一些特别的事情正在发生.</p><h3 id="只存储在栈上的数据-拷贝" tabindex="-1"><a class="header-anchor" href="#只存储在栈上的数据-拷贝" aria-hidden="true">#</a> 只存储在栈上的数据: 拷贝</h3><p>还有一点我们没有提到的是. 使用整型的代码, 拷贝的过程就如图表4-2所示:</p><div class="language-rust ext-rs line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span>

    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;x = {}, y = {}&quot;</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>但以上代码好像和我们之前所了解到的内容相违背了: 我们并没有调用 <code>clone</code> 方法, 但是 <code>x</code> 始终是合法的而且它的值并没有被移动至 <code>y</code>.</p><p>原因是, 某些类型(如整型)在编译阶段大小已知, 并且全部存储在栈中, 所以对实际数据的拷贝很容易就实现. 这样的话, 当我们创建 <code>y</code> 变量之后, 就无需将 <code>x</code> 置为无效了. 也就是说, 对于这些类型来说, 无需区分深拷贝和浅拷贝, 是否调用 <code>clone</code> 都不会有差别.</p><blockquote><p>Fish&#39;s Notes: 目前不了解 trait 的具体含义, 因此下面暂时不对其进行翻译. (2022-03-11)</p></blockquote><p>Rust 有一个特殊的注解: <code>Copy</code> trait, 可以用在存储于栈中的数据类型(比如整型)中, 我们会在第十章对 trait 进行详细的介绍. 如果一个类型实现了 <code>Copy</code> trait, 那么一个变量在赋值给另一个变量之后, 原变量依然是合法的. 对于实现了 <code>Drop</code> trait 的类型, Rust 不会允许该类型再实现 <code>Copy</code> trait. 如果某个类型的变量在离开作用域之后需要进行一些特殊的处理, 但我们为其添加了 <code>Copy</code> 注解的话, 就会遇到编译错误. 在附录 C - <a href="https://doc.rust-lang.org/book/appendix-03-derivable-traits.html" target="_blank" rel="noopener noreferrer">实现可派生特性<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>中, 我们可以了解到如何为某个类型的值添加 <code>Copy</code> trait.</p><blockquote><p>Fish&#39;s confusion: What is some form of resource?</p></blockquote><p>那么哪些类型本身实现了 <code>Copy</code> trait 呢? 我们可以通过查看各个类型的文档来确定, 不过有一个基本的规则就是, 任何一组简单标量值的组合都可以实现 <code>Copy</code>, 不需要分配内存的类型或者属于特定形式资源的类型也可以实现 <code>Copy</code>. 下面列举了能够实现 <code>Copy</code> 方法的类型:</p><ul><li>所有整型, 比如 <code>u32</code></li><li>布尔类型: <code>bool</code>, 值为 <code>true</code> 或者 <code>false</code></li><li>所有浮点数类型, 比如 <code>f64</code></li><li>字符类型, <code>char</code></li><li>元组类型, 不过需要确保其中的每一项都实现了 <code>Copy</code>. 比如 <code>(i32, i32)</code>, 两项都实现了 <code>Copy</code>, 但是 <code>(i32, String)</code> 就不.</li></ul><h3 id="所有权和函数" tabindex="-1"><a class="header-anchor" href="#所有权和函数" aria-hidden="true">#</a> 所有权和函数</h3><p>在函数中传参与为变量赋值的语法类似. 给函数传递参数会进行移动(move)或者拷贝(copy)的操作, 和赋值进行的操作是一致的. 代码示例4-3在注释中详细说明了变量在哪个位置进入和离开作用域.</p><div class="language-rust ext-rs line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// s 进入作用域</span>

    <span class="token function">takes_ownership</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// s 的值被移动到函数中</span>
                                    <span class="token comment">// 函数执行结束之后被 drop, 在这里就不合法了 </span>

    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>                      <span class="token comment">// x 进入作用域</span>

    <span class="token function">makes_copy</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">// x 的值被移动到函数中</span>
                                    <span class="token comment">// 因为类型是 i32, 所以是 Copy, 因此 x 变量始终存在</span>

<span class="token punctuation">}</span> 
<span class="token comment">// x 在这里离开作用域, 然后是 s, 因为 s 的值被 move, 所以没有什么特别的事情发生</span>


<span class="token keyword">fn</span> <span class="token function-definition function">takes_ownership</span><span class="token punctuation">(</span>some_string<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// some_string 进入作用域</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{}&quot;</span><span class="token punctuation">,</span> some_string<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token comment">// some_string 在这里离开作用域, `drop` 被调用. 所占用的内存被释放</span>

<span class="token keyword">fn</span> <span class="token function-definition function">makes_copy</span><span class="token punctuation">(</span>some_integer<span class="token punctuation">:</span> <span class="token keyword">i32</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// some_integer 进入作用域</span>
    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;{}&quot;</span><span class="token punctuation">,</span> some_integer<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token comment">// some_integer 在这里离开作用域</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>如果调用 <code>takes_ownership</code> 之后再使用 <code>s</code> 编译器会报错, 静态检查会免于我们碰到错误. 可以添加代码到 <code>main</code> 函数中, 尝试使用 <code>s</code> 和 <code>x</code> 以确认你能够在哪里使用它们, 并了解所有权规则是如何限制它们的使用的.</p><h3 id="返回值和作用域" tabindex="-1"><a class="header-anchor" href="#返回值和作用域" aria-hidden="true">#</a> 返回值和作用域</h3><p>从函数中返回值同样能够转移所有权. 代码示例4-4中的, 展示了返回某个值的函数示例, 同样这里也对每一行关键代码添加了注释.</p><div class="language-rust ext-rs line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token function">gives_ownership</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// gives_ownership 将其返回值 move 给 s1 </span>

    <span class="token keyword">let</span> s2 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// s2 进入作用域</span>

    <span class="token keyword">let</span> s3 <span class="token operator">=</span> <span class="token function">takes_and_gives_back</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// s2 被 move 到 takes_and_gives_back, 同时函数返回值被 move 给 s3</span>

<span class="token punctuation">}</span> <span class="token comment">// s3 在这里跳出作用域, 然后被 drop, s2 被 move, 因此无事发生. s1 跳出作用域然后被 drop </span>

<span class="token keyword">fn</span> <span class="token function-definition function">gives_ownership</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">String</span> <span class="token punctuation">{</span>
    <span class="token comment">// 调用 gives_ownership 会 move 返回值</span>

    <span class="token keyword">let</span> some_string <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;yours&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// some_string 进入作用域</span>

    some_string <span class="token comment">// some_string 被返回 </span>
<span class="token punctuation">}</span>

<span class="token comment">// 该函数接受一个 String, 然后返回它 </span>
<span class="token keyword">fn</span> <span class="token function-definition function">takes_and_gives_back</span><span class="token punctuation">(</span>a_string<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token class-name">String</span> <span class="token punctuation">{</span>
    <span class="token comment">// a_string 进入作用域</span>

    a_string <span class="token comment">// a_string 被返回并被 move 出</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><p>变量的所有权每次都遵循同样的模式: 将值赋给所 move 的变量. 当包含栈数据的变量跳出作用域, <code>drop</code> 之后值就会被释放, 除非数据的所有权被转移给另一个变量.</p><p>尽管如此, 通过函数获取控制权和返回控制权依然有点复杂. 如果我们想要让函数使用某个值, 但是不获取控制权, 应该怎么做呢? 如果所有值都需要传入传出使用的话, 难免有些繁琐. 除此之外, 我们还要从函数中返回某些我们所想要的数据, 就更麻烦了.</p><p>对于这种情况, Rust 允许我们使用元组 (tuple) 类型来返回多个值, 看代码示例4-5:</p><div class="language-rust ext-rs line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">let</span> <span class="token punctuation">(</span>s2<span class="token punctuation">,</span> len<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">calculate_length</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">&quot;The length of &#39;{}&#39; is {}.&quot;</span><span class="token punctuation">,</span> s2<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function-definition function">calculate_length</span><span class="token punctuation">(</span>s<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token keyword">usize</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> length <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// len() 返回 String 的长度值</span>

    <span class="token punctuation">(</span>s<span class="token punctuation">,</span> length<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>但这还是太形式主义了, 一个常用的场景, 实现起来却需要耗费那么大精力. 还好 Rust 提供了另一个特性, 我们不需要手动获取使用权, 就能够使用值, 这个特性叫做 <strong>引用</strong> (<em>reference</em>).</p><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: icyyfish@gmail.com">Fish</span><!----><!--]--><!--]--></span></div></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/the-rust-programming-language/assets/app.b3a2ff78.js" defer></script>
  </body>
</html>
